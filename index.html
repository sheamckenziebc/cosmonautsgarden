<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>The Cosmonaut's Garden</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden;
      background: #000;
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      cursor: none; /* Hide the default cursor */
    }
    /* Container for Three.js Canvas with a gradient background that transitions */
    #scene-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 0;
      background: radial-gradient(circle at center, #070b34, #000 80%);
      transition: background 2s ease;
    }
    
    /* Custom cursor styling */
    #cursor {
      position: fixed;
      width: 32px;
      height: 32px;
      background-image: url('images/sprite1.png');
      background-size: contain;
      background-repeat: no-repeat;
      pointer-events: none; /* Ensures the cursor doesn't interfere with clicks */
      z-index: 9999;
      transform: translate(-50%, -50%); /* Center the cursor on the actual pointer position */
      transition: transform 0.05s ease-out; /* Slight smoothing effect */
    }
  </style>
</head>
<body>
  <!-- Three.js Scene Container -->
  <div id="scene-container"></div>
  
  <!-- Custom Cursor Element -->
  <div id="cursor"></div>
  
  <!-- Three.js (CDN) -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
  <script>
    // =============================
    // Custom Cursor Implementation
    // =============================
    const cursor = document.getElementById('cursor');
    
    document.addEventListener('mousemove', (e) => {
      // Update cursor position with the mouse
      cursor.style.left = e.clientX + 'px';
      cursor.style.top = e.clientY + 'px';
    });
    
    // Hide cursor when mouse leaves the window
    document.addEventListener('mouseout', () => {
      cursor.style.display = 'none';
    });
    
    // Show cursor when mouse enters the window
    document.addEventListener('mouseover', () => {
      cursor.style.display = 'block';
    });
    
    // =============================
    // 1) Scene & Camera Setup
    // =============================
    let scene, camera, renderer, clock, particleSystem, uniforms;
    const container = document.getElementById('scene-container');
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 50;
    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    container.appendChild(renderer.domElement);
    
    // =============================
    // 2) Particle Swirl & Cascading Geometry
    // =============================
    const particleCount = 20000;
    const positions = new Float32Array(particleCount * 3);
    const speeds = new Float32Array(particleCount);
    const particleStates = new Float32Array(particleCount); // 0 = in column, 1 = being dragged
    const originalPositions = new Float32Array(particleCount * 3); // Store original positions for refilling
    // Define a vertical fall range (from -40 to +40)
    const fallRange = 80;
    const fallHalf = fallRange * 0.5;
    for (let i = 0; i < particleCount; i++) {
      const r = Math.random() * 5 + 10;          // radial distance between 10 and 15
      const angle = Math.random() * Math.PI * 2;   // angle around the y-axis
      // y position is randomly within the vertical range
      const y = (Math.random() - 0.5) * fallRange;
      positions[i * 3]     = r * Math.cos(angle);
      positions[i * 3 + 1] = y;
      positions[i * 3 + 2] = r * Math.sin(angle);
      
      // Store original positions for refilling
      originalPositions[i * 3]     = positions[i * 3];
      originalPositions[i * 3 + 1] = positions[i * 3 + 1];
      originalPositions[i * 3 + 2] = positions[i * 3 + 2];
      
      // Use individual speed only for the rotation
      speeds[i] = (Math.random() * 0.5) + 0.5;
      particleStates[i] = 0; // All particles start in the column
    }
    const geometry = new THREE.BufferGeometry();
    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geometry.setAttribute('aSpeed', new THREE.BufferAttribute(speeds, 1));
    geometry.setAttribute('aState', new THREE.BufferAttribute(particleStates, 1));
    
    // =============================
    // 3) Shaders (Twirling & Cascading)
    // =============================
    // Uniforms (removed collision avoidance-related uniforms)
    uniforms = {
      uTime:   { value: 0 },
      uColor1: { value: new THREE.Color('#0ed2f7') },
      uColor2: { value: new THREE.Color('#ffffff') },
      uMousePosition: { value: new THREE.Vector3(0, 0, 0) },
      uMousePressed: { value: 0.0 }
    };
    
    const vertexShader = `
      uniform float uTime;
      uniform vec3 uMousePosition;
      uniform float uMousePressed;
      attribute float aSpeed;
      attribute float aState;
      varying float vFade;
      
      void main() {
          vec3 pos = position;
          vec3 finalPosition;
          
          if (aState < 0.5) {
              // Particle is in the column
              // Rotate around Y-axis (vertical column rotating around center)
              float rotationAngle = uTime * 0.1;
              float cosA = cos(rotationAngle);
              float sinA = sin(rotationAngle);
              
              finalPosition.x = cosA * pos.x - sinA * pos.z;
              finalPosition.z = sinA * pos.x + cosA * pos.z;
              finalPosition.y = pos.y;
              
              // Apply falling effect via modulo on y position
              finalPosition.y = mod((finalPosition.y - uTime * 0.1) + 40.0, 80.0) - 40.0;
              
              // Mouse attraction - when mouse is pressed, particles can be pulled out
              if (uMousePressed > 0.5) {
                vec3 mouseDir = uMousePosition - finalPosition;
                float dist = length(mouseDir);
                float attractStrength = 0.5 * max(0.0, 1.0 - dist / 15.0);
                if (attractStrength > 0.0) {
                  finalPosition += normalize(mouseDir) * attractStrength;
                }
              }
          } else {
              // Particle is being dragged/painted
              finalPosition = pos; // Use the current position directly
          }
          
          // Compute fade factor based on the particle's original distance (for color blending)
          vFade = 1.0 - clamp(length(pos) / 60.0, 0.0, 1.0);
          
          // Transform to view space
          vec4 viewPos = modelViewMatrix * vec4(finalPosition, 1.0);
          gl_Position = projectionMatrix * viewPos;
          gl_PointSize = 2.0;
      }
    `;
    
    const fragmentShader = `
      uniform vec3 uColor1;
      uniform vec3 uColor2;
      varying float vFade;
      
      void main() {
          vec3 color = mix(uColor2, uColor1, vFade);
          gl_FragColor = vec4(color, 1.0);
      }
    `;
    
    const material = new THREE.ShaderMaterial({
      uniforms: uniforms,
      vertexShader: vertexShader,
      fragmentShader: fragmentShader,
      blending: THREE.AdditiveBlending,
      transparent: true,
      depthWrite: false
    });
    
    particleSystem = new THREE.Points(geometry, material);
    scene.add(particleSystem);
    
    // =============================
    // 4) Update Uniforms on Resize
    // =============================
    window.addEventListener('resize', onWindowResize, false);
    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }
    
    // =============================
    // 5) Dynamic Color & Background Changes on Keystroke 'D'
    // =============================
    let targetColor1 = uniforms.uColor1.value.clone();
    let targetColor2 = uniforms.uColor2.value.clone();
    
    function generateRandomHexColor() {
      return '#' + Math.floor(Math.random() * 16777215).toString(16).padStart(6, '0');
    }
    
    function getRandomGradient() {
      const colorA = generateRandomHexColor();
      const colorB = generateRandomHexColor();
      if (Math.random() < 0.5) {
        return "radial-gradient(circle at center, " + colorA + ", " + colorB + ")";
      } else {
        const angle = Math.floor(Math.random() * 360);
        return "linear-gradient(" + angle + "deg, " + colorA + ", " + colorB + ")";
      }
    }
    
    document.addEventListener('keydown', function(event) {
      if (event.key.toLowerCase() === 'd') {
        targetColor1 = new THREE.Color(generateRandomHexColor());
        targetColor2 = new THREE.Color(generateRandomHexColor());
        container.style.background = getRandomGradient();
      }
    });
    
    // =============================
    // Mouse Interaction with Particles
    // =============================
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    let mousePressed = false;
    let lastMousePosition = new THREE.Vector3();
    const draggedParticles = new Set(); // Track which particles are being dragged
    const maxDraggedParticles = 500; // Maximum number of particles that can be dragged at once
    const refillRate = 50; // Number of particles to refill per second
    let lastRefillTime = 0;
    
    function updateMousePosition(event) {
      // Calculate mouse position in normalized device coordinates (-1 to +1)
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
      
      // Update the raycaster with the mouse position
      raycaster.setFromCamera(mouse, camera);
      
      // Calculate the point of intersection with the particle system
      const intersects = raycaster.intersectObject(particleSystem);
      
      if (intersects.length > 0) {
        // Update the mouse position uniform with the intersection point
        uniforms.uMousePosition.value.copy(intersects[0].point);
        
        // If mouse is pressed, handle particle dragging
        if (mousePressed) {
          const positionAttribute = geometry.getAttribute('position');
          const stateAttribute = geometry.getAttribute('aState');
          
          // Calculate mouse movement vector for dragging
          const mouseMovement = new THREE.Vector3().copy(intersects[0].point).sub(lastMousePosition);
          
          // Update dragged particles positions
          draggedParticles.forEach(index => {
            positionAttribute.array[index * 3] += mouseMovement.x;
            positionAttribute.array[index * 3 + 1] += mouseMovement.y;
            positionAttribute.array[index * 3 + 2] += mouseMovement.z;
          });
          
          // Try to attract new particles if we haven't reached the maximum
          if (draggedParticles.size < maxDraggedParticles) {
            // Find particles close to the mouse position that are still in the column
            for (let i = 0; i < particleCount; i++) {
              if (stateAttribute.array[i] < 0.5) { // Only consider particles in the column
                const px = positionAttribute.array[i * 3];
                const py = positionAttribute.array[i * 3 + 1];
                const pz = positionAttribute.array[i * 3 + 2];
                
                const particlePos = new THREE.Vector3(px, py, pz);
                const distance = particlePos.distanceTo(intersects[0].point);
                
                // If particle is close enough to the mouse and we haven't reached the limit
                if (distance < 5 && draggedParticles.size < maxDraggedParticles) {
                  // Mark this particle as being dragged
                  stateAttribute.array[i] = 1.0;
                  draggedParticles.add(i);
                }
              }
            }
          }
          
          positionAttribute.needsUpdate = true;
          stateAttribute.needsUpdate = true;
        }
        
        // Update last mouse position for next frame
        lastMousePosition.copy(intersects[0].point);
      }
    }
    
    document.addEventListener('mousemove', updateMousePosition);
    
    document.addEventListener('mousedown', function() {
      mousePressed = true;
      uniforms.uMousePressed.value = 1.0;
    });
    
    document.addEventListener('mouseup', function() {
      mousePressed = false;
      uniforms.uMousePressed.value = 0.0;
    });
    
    // Function to refill particles in the column over time
    function refillParticles(deltaTime) {
      if (draggedParticles.size === 0) return; // No need to refill if no particles are dragged
      
      const positionAttribute = geometry.getAttribute('position');
      const stateAttribute = geometry.getAttribute('aState');
      
      // Calculate how many particles to refill this frame
      const particlesToRefill = Math.floor(refillRate * deltaTime);
      if (particlesToRefill <= 0) return;
      
      // Convert set to array for easier manipulation
      const draggedArray = Array.from(draggedParticles);
      
      // Refill up to the calculated number of particles
      for (let i = 0; i < Math.min(particlesToRefill, draggedArray.length); i++) {
        const index = draggedArray[i];
        
        // Reset particle position to its original position in the column
        positionAttribute.array[index * 3] = originalPositions[index * 3];
        positionAttribute.array[index * 3 + 1] = originalPositions[index * 3 + 1];
        positionAttribute.array[index * 3 + 2] = originalPositions[index * 3 + 2];
        
        // Reset particle state to be in the column
        stateAttribute.array[index] = 0.0;
        
        // Remove from dragged particles set
        draggedParticles.delete(index);
      }
      
      positionAttribute.needsUpdate = true;
      stateAttribute.needsUpdate = true;
    }
    
    // =============================
    // 6) Animation Loop
    // =============================
    clock = new THREE.Clock();
    function animate() {
      requestAnimationFrame(animate);
      const elapsed = clock.getElapsedTime();
      const deltaTime = clock.getDelta();
      
      uniforms.uTime.value = elapsed;
      
      // Refill particles over time
      refillParticles(deltaTime);
      
      // Gradually tween shader colors toward the target colors
      uniforms.uColor1.value.lerp(targetColor1, 0.05);
      uniforms.uColor2.value.lerp(targetColor2, 0.05);
      
      // Optional subtle camera drift:
      camera.position.x = Math.sin(elapsed * 0.2) * 5;
      camera.position.y = Math.cos(elapsed * 0.1) * 3;
      camera.lookAt(scene.position);
      
      renderer.render(scene, camera);
    }
    animate();
  </script>
</body>
</html> 